1757. Recyclable and Low Fat Products
Solved
Easy

Table: Products

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_id  | int     |
| low_fats    | enum    |
| recyclable  | enum    |
+-------------+---------+
product_id is the primary key (column with unique values) for this table.
low_fats is an ENUM (category) of type ('Y', 'N') where 'Y' means this product is low fat and 'N' means it is not.
recyclable is an ENUM (category) of types ('Y', 'N') where 'Y' means this product is recyclable and 'N' means it is not.
 

Write a solution to find the ids of products that are both low fat and recyclable.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Products table:
+-------------+----------+------------+
| product_id  | low_fats | recyclable |
+-------------+----------+------------+
| 0           | Y        | N          |
| 1           | Y        | Y          |
| 2           | N        | Y          |
| 3           | Y        | Y          |
| 4           | N        | N          |
+-------------+----------+------------+
Output: 
+-------------+
| product_id  |
+-------------+
| 1           |
| 3           |
+-------------+
Explanation: Only products 1 and 3 are both low fat and recyclable.

---------------------------------------------
SOLUTION
---------------------------------------------
select product_id
from products
where low_fats = 'Y'
    and recyclable = 'Y'
order by product_id
;

-----------------------------------------------------------------------------------------------------------------

584. Find Customer Referee
Solved
Easy
Topics
Companies
Hint
SQL Schema
Pandas Schema
Table: Customer

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| referee_id  | int     |
+-------------+---------+
In SQL, id is the primary key column for this table.
Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.
 

Find the names of the customer that are not referred by the customer with id = 2.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Customer table:
+----+------+------------+
| id | name | referee_id |
+----+------+------------+
| 1  | Will | null       |
| 2  | Jane | null       |
| 3  | Alex | 2          |
| 4  | Bill | null       |
| 5  | Zack | 1          |
| 6  | Mark | 2          |
+----+------+------------+
Output: 
+------+
| name |
+------+
| Will |
| Jane |
| Bill |
| Zack |
+------+

---------------------------------------------
SOLUTION
---------------------------------------------
SELECT name
FROM customer
WHERE coalesce(referee_id, 0) <> 2;
SELECT NAME
FROM CUSTOMER
WHERE referee_id != 2
    OR referee_id is null;
-----------------------------------------------------------------------------------------------------------------

595. Big Countries
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: World

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| name        | varchar |
| continent   | varchar |
| area        | int     |
| population  | int     |
| gdp         | bigint  |
+-------------+---------+
name is the primary key (column with unique values) for this table.
Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.
 

A country is big if:

it has an area of at least three million (i.e., 3000000 km2), or
it has a population of at least twenty-five million (i.e., 25000000).
Write a solution to find the name, population, and area of the big countries.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
World table:
+-------------+-----------+---------+------------+--------------+
| name        | continent | area    | population | gdp          |
+-------------+-----------+---------+------------+--------------+
| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
| Albania     | Europe    | 28748   | 2831741    | 12960000000  |
| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
| Andorra     | Europe    | 468     | 78115      | 3712000000   |
| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
+-------------+-----------+---------+------------+--------------+
Output: 
+-------------+------------+---------+
| name        | population | area    |
+-------------+------------+---------+
| Afghanistan | 25500100   | 652230  |
| Algeria     | 37100000   | 2381741 |
+-------------+------------+---------+

---------------------------------------------
SOLUTION
---------------------------------------------

select name,
    population,
    area
from world
where area >= 3000000 
    or population >= 25000000
;

-----------------------------------------------------------------------------------------------------------------

1148. Article Views I
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Views

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
There is no primary key (column with unique values) for this table, the table may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some date. 
Note that equal author_id and viewer_id indicate the same person.
 

Write a solution to find all the authors that viewed at least one of their own articles.

Return the result table sorted by id in ascending order.

The result format is in the following example.
Example 1:

Input: 
Views table:
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+
Output: 
+------+
| id   |
+------+
| 4    |
| 7    |
+------+

---------------------------------------------
SOLUTION
---------------------------------------------
select distinct author_id as id
from views
where author_id = viewer_id
order by author_id asc
;

-----------------------------------------------------------------------------------------------------------------

1683. Invalid Tweets
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Tweets

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| tweet_id       | int     |
| content        | varchar |
+----------------+---------+
tweet_id is the primary key (column with unique values) for this table.
content consists of alphanumeric characters, '!', or ' ' and no other special characters.
This table contains all the tweets in a social media app.
 
Write a solution to find the IDs of the invalid tweets. 
The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Tweets table:
+----------+-----------------------------------+
| tweet_id | content                           |
+----------+-----------------------------------+
| 1        | Let us Code                       |
| 2        | More than fifteen chars are here! |
+----------+-----------------------------------+
Output: 
+----------+
| tweet_id |
+----------+
| 2        |
+----------+
Explanation: 
Tweet 1 has length = 11. It is a valid tweet.
Tweet 2 has length = 33. It is an invalid tweet.

---------------------------------------------
SOLUTION
---------------------------------------------

select tweet_id
from Tweets
where length(content) > 15
;

-----------------------------------------------------------------------------------------------------------------

1378. Replace Employee ID With The Unique Identifier
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Employees

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table contains the id and the name of an employee in a company.
 

Table: EmployeeUNI

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| unique_id     | int     |
+---------------+---------+
(id, unique_id) is the primary key (combination of columns with unique values) for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the company.
 

Write a solution to show the unique ID of each user, If a user does not have a unique ID replace just show null.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+
EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+
Output: 
+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+
Explanation: 
Alice and Bob do not have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1.
---------------------------------------------
SOLUTION
---------------------------------------------

select eu.unique_id, 
	e.name
from Employees e
left join EmployeeUNI eu
    on e.id = eu.id
;
select
    unique_id,
    name
from Employees
left join EmployeeUNI
using (id);

-----------------------------------------------------------------------------------------------------------------

1068. Product Sales Analysis I
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Sales

+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| sale_id     | int   |
| product_id  | int   |
| year        | int   |
| quantity    | int   |
| price       | int   |
+-------------+-------+
(sale_id, year) is the primary key (combination of columns with unique values) of this table.
product_id is a foreign key (reference column) to Product table.
Each row of this table shows a sale on the product product_id in a certain year.
Note that the price is per unit.

Table: Product

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
+--------------+---------+
product_id is the primary key (column with unique values) of this table.
Each row of this table indicates the product name of each product.
 

Write a solution to report the product_name, year, and price for each sale_id in the Sales table.

Return the resulting table in any order.

The result format is in the following example.

Example 1:

Input: 
Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+ 
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+
Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+
Output: 
+--------------+-------+-------+
| product_name | year  | price |
+--------------+-------+-------+
| Nokia        | 2008  | 5000  |
| Nokia        | 2009  | 5000  |
| Apple        | 2011  | 9000  |
+--------------+-------+-------+
Explanation: 
From sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.
From sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.
From sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.
---------------------------------------------
SOLUTION
---------------------------------------------

select p.product_name,
    s.year,
    s.price
from sales s
join product p
    on s.product_id = p.product_id
;

Use INNER JOIN — and here's why:
You only want sales that actually happened, i.e., rows in the Sales table. Since every product_id in Sales refers to an existing product in Product, you're only interested in matching rows.

Also:
The question says:

“Report the product_name, year, and price for each sale_id in the Sales table.”

That means: Only rows from Sales that have a valid product_id.

-----------------------------------------------------------------------------------------------------------------

1581. Customer Who Visited but Did Not Make Any Transactions
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Visits

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| visit_id    | int     |
| customer_id | int     |
+-------------+---------+
visit_id is the column with unique values for this table.
This table contains information about the customers who visited the mall.
 

Table: Transactions

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| transaction_id | int     |
| visit_id       | int     |
| amount         | int     |
+----------------+---------+
transaction_id is column with unique values for this table.
This table contains information about the transactions made during the visit_id.
 

Write a solution to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.

Return the result table sorted in any order.

The result format is in the following example.

 

Example 1:

Input: 
Visits
+----------+-------------+
| visit_id | customer_id |
+----------+-------------+
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |
+----------+-------------+
Transactions
+----------------+----------+--------+
| transaction_id | visit_id | amount |
+----------------+----------+--------+
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |
+----------------+----------+--------+
Output: 
+-------------+----------------+
| customer_id | count_no_trans |
+-------------+----------------+
| 54          | 2              |
| 30          | 1              |
| 96          | 1              |
+-------------+----------------+
Explanation: 
Customer with id = 23 visited the mall once and made one transaction during the visit with id = 12.
Customer with id = 9 visited the mall once and made one transaction during the visit with id = 13.
Customer with id = 30 visited the mall once and did not make any transactions.
Customer with id = 54 visited the mall three times. During 2 visits they did not make any transactions, and during one visit they made 3 transactions.
Customer with id = 96 visited the mall once and did not make any transactions.
As we can see, users with IDs 30 and 96 visited the mall one time without making any transactions. Also, user 54 visited the mall twice and did not make any transactions.

---------------------------------------------
SOLUTION
---------------------------------------------
select distinct v.customer_id,
    count(v.visit_id) over (partition by customer_id) as count_no_trans
from Visits v
left join Transactions t
    on v.visit_id = t.visit_id
where t.transaction_id is null
;

-----------------------------------------------------------------------------------------------------------------

197. Rising Temperature
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Weather

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id is the column with unique values for this table.
There are no different rows with the same recordDate.
This table contains information about the temperature on a certain day.
 

Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Weather table:
+----+------------+-------------+
| id | recordDate | temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
Output: 
+----+
| id |
+----+
| 2  |
| 4  |
+----+
Explanation: 
In 2015-01-02, the temperature was higher than the previous day (10 -> 25).
In 2015-01-04, the temperature was higher than the previous day (20 -> 30).


---------------------------------------------
SOLUTION
---------------------------------------------

WITH previous_weatherdata_cte AS (
    SELECT id,
        recordDate,
        temperature,
        LAG(temperature, 1) OVER (ORDER BY recordDate) AS "previous_day_temp",
        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS "previous_recordDate"
    FROM Weather
)
SELECT id
FROM previous_weatherdata_cte
WHERE temperature > previous_day_temp
    AND DATEDIFF(recordDate, previous_recordDate) = 1
;

or

SELECT prev.id
FROM Weather prev
JOIN Weather w2
ON prev.recordDate = w2.recordDate + INTERVAL 1 DAY
WHERE prev.temperature > w2.temperature;

-----------------
Leetcode Approach
-----------------
Approach 1: Using JOIN and DATEDIFF()
Intuition
By doing a self-join on the Weather table, we create a Cartesian product of the table with itself, creating pairs of days. We then use the DATEDIFF function to restrict these pairs to only include consecutive days. Lastly, we filter these pairs of consecutive days further to only include pairs where the temperature is higher on the second day. The resulting ids represent the days where the temperature was higher than the previous day.

Let's break this down step by step:

Step 1: Defining the Main Query Structure

SELECT 
    w1.id
FROM 
    Weather w1
JOIN 
    Weather w2
Here, we are setting up a query to retrieve the id from the Weather table aliased as w1. To find the records where the temperature is greater than the previous day, we are performing a self-join on the Weather table, creating a second alias w2. This allows us to compare each record in w1 with each record in w2.

Step 2: Join Condition

ON 
    DATEDIFF(w1.recordDate, w2.recordDate) = 1
In the join condition, we are using the DATEDIFF function to find pairs of records where the recordDate differs by exactly one day. This condition ensures that we are comparing each day's temperature with the temperature of the previous day.

Step 3: Filter Records with Higher Temperature

WHERE 
    w1.temperature > w2.temperature;
After finding pairs of days that are consecutive, we apply a filter in the WHERE clause to only get the records where the temperature on a day (represented by a record in w1) is greater than the temperature on the previous day (represented by a record in w2). This is the main condition to fulfill the requirement of finding the ids where the temperature is higher than the previous day.

Implementation
SELECT 
    w1.id
FROM 
    Weather w1
JOIN 
    Weather w2
ON 
    DATEDIFF(w1.recordDate, w2.recordDate) = 1
WHERE 
    w1.temperature > w2.temperature;
Approach 2: Using LAG() Function
Intuition
Let's break this down step by step:

Step 1: Creating a Common Table Expression (CTE) with Lag Function

WITH PreviousWeatherData AS
(
    SELECT 
        id,
        recordDate,
        temperature, 
        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,
        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate
    FROM 
        Weather
)
In this step, we create a Common Table Expression (CTE) named PreviousWeatherData using a WITH clause. Inside this CTE, we are selecting all the rows from the "Weather" table along with two additional columns:

PreviousTemperature: The temperature from the previous day, which is obtained using the LAG() function with an offset of 1, ordered by recordDate.
PreviousRecordDate: The record date of the previous day, similarly obtained using the LAG() function with an offset of 1, ordered by recordDate.
This setup helps us associate each record with the respective details from the previous day in the same row.

Step 2: Selecting IDs with Conditions on Temperature and Date

SELECT 
    id 
FROM 
    PreviousWeatherData
WHERE 
    temperature > PreviousTemperature
AND 
    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);
In this step, we execute a query on the PreviousWeatherData CTE with two conditions in the WHERE clause to filter the required IDs:

temperature > PreviousTemperature: This condition filters for the days where the temperature was higher than the previous day's temperature.
recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY): This condition ensures that we are comparing consecutive days. It uses the DATE_ADD() function to add an interval of 1 day to the PreviousRecordDate and checks if it equals the current recordDate.
By combining these two conditions with an AND clause, we ensure that we only select the IDs where both conditions are met, which are the days when the temperature is higher than the day before.

Implementation
WITH PreviousWeatherData AS
(
    SELECT 
        id,
        recordDate,
        temperature, 
        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,
        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate
    FROM 
        Weather
)
SELECT 
    id 
FROM 
    PreviousWeatherData
WHERE 
    temperature > PreviousTemperature
AND 
    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);
Approach 3: Using Subquery
Intuition
Let's break this down step by step:

Step 1: Inner Subquery to Get the Previous Day’s Temperature

        SELECT 
            w2.temperature
        FROM 
            Weather w2
        WHERE 
            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)
The inner query is responsible for retrieving the temperature of the day before the date currently under consideration in the outer query.

It utilizes the DATE_SUB function to find the date one day before the recordDate in the outer query (w1.recordDate) and then fetches the temperature recorded on that previous date from the same Weather table (alias w2).

Step 2: Outer Query to Find Days with Higher Temperature

SELECT 
    w1.id
FROM 
    Weather w1
WHERE 
    w1.temperature > (
        -- ... (inner subquery)
    );
The outer query iterates over each row (each day) in the Weather table (alias w1) and checks if the temperature on that day is greater than the temperature on the previous day, the latter being obtained from the inner subquery.

Step 3: Comparing Temperatures

    w1.temperature > (
        -- ... (inner subquery)
    )
Here, we have the crucial comparison that serves our goal. For each day in the outer query, it checks whether the temperature is greater than the temperature fetched from the inner subquery (which is the temperature of the previous day).

Step 4: Selecting the ID

SELECT 
    w1.id
If the condition in the WHERE clause is satisfied (today’s temperature is greater than yesterday’s), we select the ID of the current day (from the outer query’s perspective). This ID indicates a day where the temperature was higher than the temperature on the previous day.

Implementation
SELECT 
    w1.id
FROM 
    Weather w1
WHERE 
    w1.temperature > (
        SELECT 
            w2.temperature
        FROM 
            Weather w2
        WHERE 
            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)
    );
Approach 4: Using Cartesian Product and WHERE Clause
Intuition
Let's break this down step by step:

Step 1: Cartesian Product

FROM 
    Weather w1, Weather w2
In this step, we are performing a Cartesian product (or cross join) of the Weather table with itself. This means we create a new table where each row from w1 (first instance of the Weather table) is paired with every row from w2 (second instance of the Weather table), resulting in a table with n² rows (where n is the number of rows in the Weather table).

Step 2: Filtering Based on Date Difference

WHERE 
    DATEDIFF(w2.recordDate, w1.recordDate) = 1 
Next, we use the DATEDIFF function to find pairs of rows where the difference between the 'recordDate' in w2 and w1 is exactly 1 day. This effectively filters down to pairs of rows representing consecutive days.

Step 3: Filtering Based on Temperature Difference

AND 
    w2.temperature > w1.temperature;
In this step, we are filtering the pairs further to retain only those where the temperature on the second day (w2.temperature) is greater than the temperature on the first day (w1.temperature). This finds the days where the temperature is rising compared to the previous day.

Step 4: Selecting the Result

SELECT 
    w2.id
Finally, from all the pairs that satisfy the conditions set in the WHERE clause, we select the ID of the day from the w2 table (i.e., the ID of the day with the higher temperature).

Implementation
SELECT 
    w2.id
FROM 
    Weather w1, Weather w2
WHERE 
    DATEDIFF(w2.recordDate, w1.recordDate) = 1 
AND 
    w2.temperature > w1.temperature;



-----------------------------------------------------------------------------------------------------------------
1661. Average Time of Process per Machine
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Activity

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| machine_id     | int     |
| process_id     | int     |
| activity_type  | enum    |
| timestamp      | float   |
+----------------+---------+
The table shows the user activities for a factory website.
(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.
machine_id is the ID of a machine.
process_id is the ID of a process running on the machine with ID machine_id.
activity_type is an ENUM (category) of type ('start', 'end').
timestamp is a float representing the current time in seconds.
'start' means the machine starts the process at the given timestamp and 'end' means the machine ends the process at the given timestamp.
The 'start' timestamp will always be before the 'end' timestamp for every (machine_id, process_id) pair.
It is guaranteed that each (machine_id, process_id) pair has a 'start' and 'end' timestamp.
 

There is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to complete a process.

The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.

The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Activity table:
+------------+------------+---------------+-----------+
| machine_id | process_id | activity_type | timestamp |
+------------+------------+---------------+-----------+
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |
+------------+------------+---------------+-----------+
Output: 
+------------+-----------------+
| machine_id | processing_time |
+------------+-----------------+
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |
+------------+-----------------+
Explanation: 
There are 3 machines running 2 processes each.
Machine 0's average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894
Machine 1's average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995
Machine 2's average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456

---------------------------------------------
SOLUTION
---------------------------------------------
SELECT a.machine_id,
    ROUND(AVG(b.timestamp - a.timestamp) , 3) AS processing_time
FROM Activity a,
    Activity b
WHERE a.machine_id = b.machine_id
    AND a.process_id = b.process_id
    AND a.activity_type = 'start'
    AND b.activity_type = 'end'
GROUP BY a.machine_id
;

-----------------
LEETCODE Approach
-----------------
Approach 1: Transform Values with CASE WHEN and then Calculate
Algorithm
To calculate the time to complete a process, we need to know the difference between the 'start' timestamp and the 'end' timestamp for each machine and process. If we set all the 'start' timestamp to its negative value, we can get the time difference by using SUM(), since (-start) + end is equal to end - start, which is the time difference.

To do this, we use CASE WHEN to multiply all the start timestamp by -1, so the aggregated total of timestamp becomes the time to complete a process for each machine.

SUM(CASE WHEN activity_type = 'start' THEN timestamp*-1 ELSE timestamp END)
Since we need the average by each machine_id and there might be multiple processes for each machine, we manually calculate the average by having the processing time divided by the number of processes. Luckily, for this question, all machines have the same number of processes.

SUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0/(SELECT COUNT(DISTINCT process_id))
Lastly, we round the processing_time to 3 decimal places by using the function ROUND() and rename the column name.

ROUND(SUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0/(SELECT COUNT(DISTINCT process_id)),3) AS processing_time
Implementation
SELECT 
    machine_id,
    ROUND(SUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0
    / (SELECT COUNT(DISTINCT process_id)),3) AS processing_time
FROM 
    Activity
GROUP BY machine_id
​

Approach 2: Calling the original Table twice and Calculate as two columns
Algorithm
For this approach, we are calling the original table twice, once as the table that stores the start timestamps and once as the table that stores the end timestamps. To create the table alias, we give the original table Activity two different names, and filter each table by the activity_type. We also make sure the two tables are joined on the machine_id and process_id, so the output will have the start timestamp and end timestamp stored in two different columns for each machine and process.

SELECT *
FROM Activity a, 
     Activity b
WHERE 
    a.machine_id = b.machine_id
AND 
    a.process_id = b.process_id
AND 
    a.activity_type = 'start'
AND 
    b.activity_type = 'end'
The output looks like this:

machine_id	process_id	activity_type	timestamp	machine_id	process_id	activity_type	timestamp
0	0	start	0.712	0	0	end	1.52
0	1	start	3.14	0	1	end	4.12
1	0	start	0.55	1	0	end	1.55
1	1	start	0.43	1	1	end	1.42
2	0	start	4.1	2	0	end	4.512
2	1	start	2.5	2	1	end	5
With this table, we can update the calculation for processing_time by having all the timestamps from table b (end timestamp) to subtract all the timestamp in table a (start timestamp):

SELECT (b.timestamp - a.timestamp) AS processing_time
Since we want the average processing_time at the machine_id level, we add AVG() to the processing_time calculation and round it to 3 decimal places using the function ROUND().

SELECT a.machine_id, 
       ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time
Implementation
SELECT a.machine_id, 
       ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time
FROM Activity a, 
     Activity b
WHERE 
    a.machine_id = b.machine_id
AND 
    a.process_id = b.process_id
AND 
    a.activity_type = 'start'
AND 
    b.activity_type = 'end'
GROUP BY machine_id


-----------------------------------------------------------------------------------------------------------------

577. Employee Bonus
Solved
Easy
Topics
Companies
Hint
SQL Schema
Pandas Schema
Table: Employee

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| empId       | int     |
| name        | varchar |
| supervisor  | int     |
| salary      | int     |
+-------------+---------+
empId is the column with unique values for this table.
Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.
 

Table: Bonus

+-------------+------+
| Column Name | Type |
+-------------+------+
| empId       | int  |
| bonus       | int  |
+-------------+------+
empId is the column of unique values for this table.
empId is a foreign key (reference column) to empId from the Employee table.
Each row of this table contains the id of an employee and their respective bonus.
 

Write a solution to report the name and bonus amount of each employee with a bonus less than 1000.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Employee table:
+-------+--------+------------+--------+
| empId | name   | supervisor | salary |
+-------+--------+------------+--------+
| 3     | Brad   | null       | 4000   |
| 1     | John   | 3          | 1000   |
| 2     | Dan    | 3          | 2000   |
| 4     | Thomas | 3          | 4000   |
+-------+--------+------------+--------+
Bonus table:
+-------+-------+
| empId | bonus |
+-------+-------+
| 2     | 500   |
| 4     | 2000  |
+-------+-------+
Output: 
+------+-------+
| name | bonus |
+------+-------+
| Brad | null  |
| John | null  |
| Dan  | 500   |
+------+-------+

---------------------------------------------
SOLUTION
---------------------------------------------
select e.name,
    b.bonus
from Employee e
    left join bonus b
        on e.empId = b.empId
where b.bonus < 1000
    or b.bonus is NULL
;


or

select e.name, b.bonus
from Employee e
left join Bonus b
on e.empId = b.empId
where ifnull(b.bonus, 0) < 1000

-----------------------------------------------------------------------------------------------------------------

1280. Students and Examinations
Solved
Easy
Topics
Companies
SQL Schema
Pandas Schema
Table: Students

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| student_id    | int     |
| student_name  | varchar |
+---------------+---------+
student_id is the primary key (column with unique values) for this table.
Each row of this table contains the ID and the name of one student in the school.
 

Table: Subjects

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| subject_name | varchar |
+--------------+---------+
subject_name is the primary key (column with unique values) for this table.
Each row of this table contains the name of one subject in the school.
 

Table: Examinations

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| student_id   | int     |
| subject_name | varchar |
+--------------+---------+
There is no primary key (column with unique values) for this table. It may contain duplicates.
Each student from the Students table takes every course from the Subjects table.
Each row of this table indicates that a student with ID student_id attended the exam of subject_name.

Write a solution to find the number of times each student attended each exam.

Return the result table ordered by student_id and subject_name.

The result format is in the following example.

Example 1:

Input: 
Students table:
+------------+--------------+
| student_id | student_name |
+------------+--------------+
| 1          | Alice        |
| 2          | Bob          |
| 13         | John         |
| 6          | Alex         |
+------------+--------------+
Subjects table:
+--------------+
| subject_name |
+--------------+
| Math         |
| Physics      |
| Programming  |
+--------------+
Examinations table:
+------------+--------------+
| student_id | subject_name |
+------------+--------------+
| 1          | Math         |
| 1          | Physics      |
| 1          | Programming  |
| 2          | Programming  |
| 1          | Physics      |
| 1          | Math         |
| 13         | Math         |
| 13         | Programming  |
| 13         | Physics      |
| 2          | Math         |
| 1          | Math         |
+------------+--------------+
Output: 
+------------+--------------+--------------+----------------+
| student_id | student_name | subject_name | attended_exams |
+------------+--------------+--------------+----------------+
| 1          | Alice        | Math         | 3              |
| 1          | Alice        | Physics      | 2              |
| 1          | Alice        | Programming  | 1              |
| 2          | Bob          | Math         | 1              |
| 2          | Bob          | Physics      | 0              |
| 2          | Bob          | Programming  | 1              |
| 6          | Alex         | Math         | 0              |
| 6          | Alex         | Physics      | 0              |
| 6          | Alex         | Programming  | 0              |
| 13         | John         | Math         | 1              |
| 13         | John         | Physics      | 1              |
| 13         | John         | Programming  | 1              |
+------------+--------------+--------------+----------------+
Explanation: 
The result table should contain all students and all subjects.
Alice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.
Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam.
Alex did not attend any exams.
John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.

---------------------------------------------
SOLUTION
---------------------------------------------

SELECT s.student_id,
    s.student_name,
    sub.subject_name,
    COUNT(e.student_id) AS attended_exams
FROM Students s
    CROSS JOIN Subjects sub
    LEFT JOIN Examinations e
        ON e.student_id = s.student_id
        AND e.subject_name = sub.subject_name
GROUP BY s.student_id, sub.subject_name
ORDER BY s.student_id, sub.subject_name
;

-----------
EXPLANATION
-----------

Step by Step
First, let's group subjects by student.

SELECT
    student_id
    ,student_name
    ,subject_name
Our goal is to list the subjects for each student.

Like this:

| student_id | student_name | subject_name |
| ---------- | ------------ | ------------ |
| 1          | Alice        | Programming  |
| 1          | Alice        | Physics      |
| 1          | Alice        | Math         |
| 2          | Bob          | Programming  |
| 2          | Bob          | Physics      |
| 2          | Bob          | Math         |
We're going to use a CROSS JOIN (Cartesian product)

which is like making every possible pair of rows from two tables.

SELECT
    student_id
    ,student_name
    ,subject_name
FROM Students 
CROSS JOIN Subjects

Now we need to add the exam results.

Time to LEFT JOIN so we can show a '0' for subjects students didn't take, it will be clear later.


LEFT JOIN Examinations E
connect this table to the others

LEFT JOIN Examinations E
    ON E.student_id = S.student_id
    AND E.subject_name = SU.subject_name
And ordered the results

ORDER BY S.student_id, S.student_name, SU.subject_name
SELECT
    s.student_id
    ,s.student_name
    ,SU.subject_name
FROM Students S
CROSS JOIN Subjects SU
LEFT JOIN Examinations E
    ON E.student_id = S.student_id
    AND E.subject_name = SU.subject_name
ORDER BY S.student_id, S.student_name, SU.subject_name
Output:
image.png

Each attempt at Alice's exam is displayed one after another.

And we want to count them.


We will use Count()

What exactly are we counting? We could count either e.subject_id or e.student_id, but the way we GROUP the data will be crucial.

We want to count the attempts of a given person, so now we need to assign the result to people and then to their subjects

We want to find out how many times Alice has taken an exam in a SPECIFIC subject

COUNT(e.subject_id) AS attended_exams
and we need to GROUP the results

GROUP BY S.student_id, S.student_name, Su.subject_name
final code:

SELECT
    S.student_id
    ,S.student_name
    ,Su.subject_name
    ,COUNT(E.student_id) attended_exams
FROM Students S
CROSS JOIN Subjects Su
LEFT JOIN Examinations E
    ON S.student_id = E.student_id
    AND Su.subject_name = E.subject_name
GROUP BY S.student_id, S.student_name, Su.subject_name
ORDER BY S.student_id, S.student_name, Su.subject_name
Output:

| student_id | student_name | subject_name | attended_exams |
| ---------- | ------------ | ------------ | -------------- |
| 1          | Alice        | Math         | 3              |
| 1          | Alice        | Physics      | 2              |
| 1          | Alice        | Programming  | 1              |
| 2          | Bob          | Math         | 1              |
| 2          | Bob          | Physics      | 0              |
| 2          | Bob          | Programming  | 1              |

-----------------------------------------------------------------------------------------------------------------

570. Managers with at Least 5 Direct Reports
Solved
Medium
Topics
Companies
Hint
SQL Schema
Pandas Schema
Table: Employee

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |
+-------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table indicates the name of an employee, their department, and the id of their manager.
If managerId is null, then the employee does not have a manager.
No employee will be the manager of themself.

Write a solution to find managers with at least five direct reports.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Employee table:
+-----+-------+------------+-----------+
| id  | name  | department | managerId |
+-----+-------+------------+-----------+
| 101 | John  | A          | null      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |
+-----+-------+------------+-----------+
Output: 
+------+
| name |
+------+
| John |
+------+

---------------------------------------------
SOLUTION
---------------------------------------------

select e.name
from Employee e
    join Employee m
        on e.id = m.managerId
group by e.managerId
having COUNT(*) >= 5
;

